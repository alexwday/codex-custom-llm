"""
Codex Configuration Generator

Generates ~/.codex/config.toml file with custom model provider settings.
The config file tells Codex how to connect to your enterprise LLM endpoint.
"""

import os
import logging
from pathlib import Path
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)


def generate_codex_config(config_data: Dict[str, Any]) -> Path:
    """
    Generate Codex configuration file at ~/.codex/config.toml

    Args:
        config_data: Dictionary containing:
            - base_url: Base URL for the LLM API
            - model_name: Model name to use
            - env_key: Environment variable name for auth token
            - wire_api: 'chat' or 'responses'
            - query_params: Optional query parameters (e.g., 'api-version=2024-01-01')
            - max_tokens: Optional max tokens for responses

    Returns:
        Path to the generated config file

    Raises:
        ValueError: If required config fields are missing
    """
    # Validate required fields
    required_fields = ['base_url', 'model_name', 'env_key', 'wire_api']
    for field in required_fields:
        if not config_data.get(field):
            raise ValueError(f"Missing required config field: {field}")

    # Get config directory
    config_dir = Path.home() / '.codex'
    config_file = config_dir / 'config.toml'

    # Create directory if it doesn't exist
    config_dir.mkdir(parents=True, exist_ok=True)

    # Extract config values
    base_url = config_data['base_url']
    model_name = config_data['model_name']
    env_key = config_data['env_key']
    wire_api = config_data['wire_api']
    query_params = config_data.get('query_params')
    max_tokens = config_data.get('max_tokens')

    # Validate wire_api
    if wire_api not in ['chat', 'responses']:
        raise ValueError(f"Invalid wire_api: {wire_api}. Must be 'chat' or 'responses'")

    # Generate TOML content
    toml_content = _generate_toml(
        base_url=base_url,
        model_name=model_name,
        env_key=env_key,
        wire_api=wire_api,
        query_params=query_params,
        max_tokens=max_tokens
    )

    # Write config file
    logger.info(f"Writing Codex config to {config_file}")
    config_file.write_text(toml_content)
    logger.debug(f"Config content:\n{toml_content}")

    return config_file


def _generate_toml(
    base_url: str,
    model_name: str,
    env_key: str,
    wire_api: str,
    query_params: Optional[str] = None,
    max_tokens: Optional[int] = None
) -> str:
    """
    Generate TOML configuration content.

    Args:
        base_url: Base URL for the LLM API
        model_name: Model name
        env_key: Environment variable name for token
        wire_api: API wire format
        query_params: Optional query parameters
        max_tokens: Optional max tokens for responses

    Returns:
        TOML configuration as string
    """
    # Provider ID (used to reference this provider)
    provider_id = "enterprise_llm"

    # Build the TOML structure
    lines = [
        "# Codex CLI Configuration",
        "# Generated by Enterprise Codex Wrapper",
        "",
        f'model = "{model_name}"',
        f'model_provider = "{provider_id}"',
        "",
        f"[model_providers.{provider_id}]",
        f'name = "Enterprise LLM"',
        f'base_url = "{base_url}"',
        f'env_key = "{env_key}"',
        f'wire_api = "{wire_api}"',
    ]

    # Add max_tokens if provided
    if max_tokens:
        lines.append(f'max_tokens = {max_tokens}')

    # Add query parameters if provided
    if query_params:
        lines.append(f'query_params = "{query_params}"')

    lines.append("")  # Trailing newline

    return "\n".join(lines)


def read_codex_config() -> Optional[str]:
    """
    Read the current Codex configuration.

    Returns:
        Config file contents as string, or None if file doesn't exist
    """
    config_file = Path.home() / '.codex' / 'config.toml'

    if not config_file.exists():
        return None

    return config_file.read_text()


def backup_codex_config() -> Optional[Path]:
    """
    Create a backup of the existing Codex configuration.

    Returns:
        Path to backup file, or None if no config exists
    """
    config_file = Path.home() / '.codex' / 'config.toml'

    if not config_file.exists():
        logger.info("No existing config to backup")
        return None

    # Create backup with timestamp
    import time
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    backup_file = config_file.parent / f'config.toml.backup_{timestamp}'

    logger.info(f"Backing up config to {backup_file}")
    backup_file.write_text(config_file.read_text())

    return backup_file


# Example usage and testing
if __name__ == '__main__':
    import sys

    logging.basicConfig(level=logging.DEBUG)

    # Test config generation
    test_config = {
        'base_url': 'https://llm-api.example.com/v1',
        'model_name': 'gpt-4-internal',
        'env_key': 'CUSTOM_LLM_API_KEY',
        'wire_api': 'chat',
        'query_params': 'api-version=2024-01-01'
    }

    print("Testing config generation...")
    print("\nConfig data:")
    for key, value in test_config.items():
        print(f"  {key}: {value}")

    print("\nGenerated TOML:")
    toml = _generate_toml(**test_config)
    print(toml)

    # Test file generation (with user confirmation)
    response = input("\nGenerate actual config file at ~/.codex/config.toml? (y/n): ")
    if response.lower() == 'y':
        # Backup existing config
        backup_codex_config()

        # Generate new config
        config_path = generate_codex_config(test_config)
        print(f"\nConfig written to: {config_path}")

        # Read and display
        print("\nConfig file contents:")
        print(read_codex_config())
    else:
        print("Skipped file generation")
